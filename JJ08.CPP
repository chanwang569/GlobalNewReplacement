#include <cstdlib>	//malloc, free
#include <iostream>

using namespace std;

void* myAlloc(size_t size)
{  
	return malloc(size); 
}

void myFree(void* ptr)
{
	free(ptr); 
	return;
}

//我要O一可以累分配量和放量的 operator new() / operator delete().
//除非 user 直接使用 malloc/free, 否t都避不_它, @泳涂梢岳鄯e量. 
static  size_t countNew = 0;
static  size_t countDel = 0;	    
static  size_t countArrayNew = 0;
static  size_t countArrayDel = 0;
static  size_t timesNew = 0;
//小心，@影oh弗 
//它不可被明於一 namespace  
//以下是成功的, 但我r不想要它 (免得ξ疫@整y程序碛绊). 

inline void* operator new(size_t size) 	 
{
	//cout << "jjhou global new(), \t" << size << "\t"; 
	countNew += size; 
	++timesNew;  
	
	//void* p = myAlloc( size ); 
	//cout << p << endl; 
	//return p;
	
	return myAlloc( size ); 	    
}

inline void* operator new[](size_t size)  
{ 
	//cout << "jjhou global new[](), \t" << size << "\t";
	countArrayNew += size; 				
	
	void* p = myAlloc( size ); 
	//cout << p << endl; 
	return p;
	
	//return myAlloc( size ); 	    
}	

//天啊, 以下(1)(2)可以K存K由(2)抓住流程 (但它ξ疫@旱yo用). 
//只存在 (1) r, 抓不住流程. 
//在 class members 中二者只能褚 (任一均可) 
//(1) 
inline void  operator delete(void* ptr, size_t size)  
{  	
//	cout << "jjhou global delete(ptr,size), \t" << ptr << "\t" << size << endl;	
	countDel += size;  	
	myFree( ptr ); 			
}
//(2)
inline void  operator delete(void* ptr)  
{  	
//	cout << "jjhou global delete(ptr), \t" << ptr << endl;	 	
	myFree( ptr ); 			
}	

//(1)
inline void  operator delete[](void* ptr, size_t size) 
{ 
//	cout << "jjhou global delete[](ptr,size), \t" << ptr << "\t" << size << endl;
	countArrayDel += size; 
	myFree( ptr ); 			
}	
//(2)
inline void  operator delete[](void* ptr) 
{ 
//	cout << "jjhou global delete[](ptr), \t" << ptr << endl;
	myFree( ptr ); 			
}


#include <vector>
#include <list>
/*#include <ext\pool_allocator.h> 

//C++/11 alias template
template <typename T>
using listPool = list<T, __gnu_cxx::__pool_alloc<T>>; 	
*/
namespace jj08
{
	//-------------	
	void test_overload_global_new()
	{
		{ 
			cout << "::countNew= " << ::countNew << endl;		//0
			cout << "::countDel= " << ::countDel << endl;   	//0 
			cout << "::timesNew= " << ::timesNew << endl;   	//0 
			
			string* p = new string("My name is Ace");		//jjhou global new(), 4 	(]：@是 string size) 
			//jjhou global new(), 27	(]：@是 sizeof(Rep)+extra) 
			delete p;		//jjhou global delete(ptr), 0x3e3e48
			//jjhou global delete(ptr), 0x3e3e38
			
			cout << "::countNew= " << ::countNew << endl;	//31 ==> 4+27
			cout << "::timesNew= " << ::timesNew << endl;   //2
			cout << "::countDel= " << ::countDel << endl;	//0 <== 本y@然我永h^察不到我所要^察的
			//      因檫M不去 operator delete(ptr,size) 版 	               								
			
			p = new string[3];		//jjhou global new[](), 16 (]：其中群 arraySize field: 4 bytes, 
			//所以 16-4 = 12 ==> 4*3, 也就是 3  string 每 4 bytes)
			//jjhou global new(), 13  	//Nil string
			//jjhou global new(), 13	//Nil string	
			//jjhou global new(), 13	//Nil string										
			
			delete [] p;			//jjhou global delete(ptr),   0x3e3e88
			//jjhou global delete(ptr),   0x3e3e70
			//jjhou global delete(ptr),   0x3e39c8
			//jjhou global delete[](ptr), 0x3e3978   
			
			cout << "::countNew= " << ::countNew << endl;			//70 ==> 4+27+13+13+13
			cout << "::timesNew= " << ::timesNew << endl;   		//5    
			cout << "::countArrayNew= " << ::countArrayNew << endl;	//16 (@抵灯ξ叶言o意x)
			
			//y: global operator new 也容器碛绊
			vector<int> vec(10);	//jjhou global new(), 	40  	0x3e3ea0  (]：10 ints)
			//]：vector object 本身不是 dynamic allocated. 
			vec.push_back(1); 		
			//jjhou global new(), 	80		0x3e3ed0
			//jjhou global delete(ptr), 	0x3e3ea0	
			vec.push_back(1); 		
			vec.push_back(1); 	
			
			cout << "::countNew= " << ::countNew << endl;	//190 ==> 70+40+80		
			cout << "::timesNew= " << ::timesNew << endl;   //7    
			
			list<int> lst;		//]：list object 本身不是 dynamic allocated. 	
			lst.push_back(1); 	//jjhou global new(), 	12	(]：每 node是 12 bytes) 
			lst.push_back(1); 	//jjhou global new(), 	12
			lst.push_back(1); 	//jjhou global new(), 	12
			cout << "::countNew= " << ::countNew << endl;	//226 ==> 190+12+12+12		
			cout << "::timesNew= " << ::timesNew << endl;   //10  
			
			//jjhou global delete(ptr), 	0x3e3978
			//jjhou global delete(ptr), 	0x3e39c8
			//jjhou global delete(ptr), 	0x3e3e70
			//jjhou global delete(ptr), 	0x3e3ed0	
		}
		
	/*	{
			//reset countNew
			countNew = 0;
			timesNew = 0;	
			
			//list<double, __gnu_cxx::__pool_alloc<double>> lst;	
			//上一行改用 C++/11 alias template  : 
			listPool<double> lst; 
			
			for (int i=0; i< 1000000; ++i)
				lst.push_back(i);
			cout << "::countNew= " << ::countNew << endl;  	//16752832 (注意, node 都不 cookie)
			cout << "::timesNew= " << ::timesNew << endl;   //122	
		}
		
		{
			//reset countNew
			countNew = 0;
			timesNew = 0;	
			list<double> lst;
			for (int i=0; i< 1000000; ++i)
				lst.push_back(i);
			cout << "::countNew= " << ::countNew << endl;	//16000000 (注意, node 都 cookie)
			cout << "::timesNew= " << ::timesNew << endl;   //1000000    
		}  	*/									 
	}
}
int main(int argc, char** argv) 
{
	cout << __cplusplus << endl;
	jj08::test_overload_global_new();
	return 0;
}